{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"sort\", \"searchPredicate\", \"autoFocusSearchField\", \"disableHideAllButton\", \"disableShowAllButton\", \"getTogglableColumns\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { unstable_composeClasses as composeClasses } from '@mui/utils';\nimport IconButton from '@mui/material/IconButton';\nimport { switchClasses } from '@mui/material/Switch';\nimport FormControlLabel from '@mui/material/FormControlLabel';\nimport { styled } from '@mui/material/styles';\nimport { gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector } from '../../hooks/features/columns/gridColumnsSelector';\nimport { useGridSelector } from '../../hooks/utils/useGridSelector';\nimport { useGridApiContext } from '../../hooks/utils/useGridApiContext';\nimport { GridPanelContent } from './GridPanelContent';\nimport { GridPanelFooter } from './GridPanelFooter';\nimport { GridPanelHeader } from './GridPanelHeader';\nimport { GridPanelWrapper } from './GridPanelWrapper';\nimport { GRID_EXPERIMENTAL_ENABLED } from '../../constants/envConstants';\nimport { useGridRootProps } from '../../hooks/utils/useGridRootProps';\nimport { getDataGridUtilityClass } from '../../constants/gridClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['columnsPanel'],\n    columnsPanelRow: ['columnsPanelRow']\n  };\n  return composeClasses(slots, getDataGridUtilityClass, classes);\n};\nconst GridColumnsPanelRoot = styled('div', {\n  name: 'MuiDataGrid',\n  slot: 'ColumnsPanel',\n  overridesResolver: (props, styles) => styles.columnsPanel\n})({\n  padding: '8px 0px 8px 8px'\n});\nconst GridColumnsPanelRowRoot = styled('div', {\n  name: 'MuiDataGrid',\n  slot: 'ColumnsPanelRow',\n  overridesResolver: (props, styles) => styles.columnsPanelRow\n})(({\n  theme\n}) => ({\n  display: 'flex',\n  justifyContent: 'space-between',\n  padding: '1px 8px 1px 7px',\n  [`& .${switchClasses.root}`]: {\n    marginRight: theme.spacing(0.5)\n  }\n}));\nconst GridIconButtonRoot = styled(IconButton)({\n  justifyContent: 'flex-end'\n});\nconst collator = new Intl.Collator();\nconst defaultSearchPredicate = (column, searchValue) => {\n  return (column.headerName || column.field).toLowerCase().indexOf(searchValue) > -1;\n};\nfunction GridColumnsPanel(props) {\n  var _rootProps$slotProps, _rootProps$slotProps3, _rootProps$slotProps4;\n  const apiRef = useGridApiContext();\n  const searchInputRef = React.useRef(null);\n  const columns = useGridSelector(apiRef, gridColumnDefinitionsSelector);\n  const columnVisibilityModel = useGridSelector(apiRef, gridColumnVisibilityModelSelector);\n  const rootProps = useGridRootProps();\n  const [searchValue, setSearchValue] = React.useState('');\n  const classes = useUtilityClasses(rootProps);\n  const {\n      sort,\n      searchPredicate = defaultSearchPredicate,\n      autoFocusSearchField = true,\n      disableHideAllButton = false,\n      disableShowAllButton = false,\n      getTogglableColumns\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const sortedColumns = React.useMemo(() => {\n    switch (sort) {\n      case 'asc':\n        return [...columns].sort((a, b) => collator.compare(a.headerName || a.field, b.headerName || b.field));\n      case 'desc':\n        return [...columns].sort((a, b) => -collator.compare(a.headerName || a.field, b.headerName || b.field));\n      default:\n        return columns;\n    }\n  }, [columns, sort]);\n  const toggleColumn = event => {\n    const {\n      name: field\n    } = event.target;\n    apiRef.current.setColumnVisibility(field, columnVisibilityModel[field] === false);\n  };\n  const toggleAllColumns = React.useCallback(isVisible => {\n    const currentModel = gridColumnVisibilityModelSelector(apiRef);\n    const newModel = _extends({}, currentModel);\n    const togglableColumns = getTogglableColumns ? getTogglableColumns(columns) : null;\n    columns.forEach(col => {\n      if (col.hideable && (togglableColumns == null || togglableColumns.includes(col.field))) {\n        if (isVisible) {\n          // delete the key from the model instead of setting it to `true`\n          delete newModel[col.field];\n        } else {\n          newModel[col.field] = false;\n        }\n      }\n    });\n    return apiRef.current.setColumnVisibilityModel(newModel);\n  }, [apiRef, columns, getTogglableColumns]);\n  const handleSearchValueChange = React.useCallback(event => {\n    setSearchValue(event.target.value);\n  }, []);\n  const currentColumns = React.useMemo(() => {\n    const togglableColumns = getTogglableColumns ? getTogglableColumns(sortedColumns) : null;\n    const togglableSortedColumns = togglableColumns ? sortedColumns.filter(({\n      field\n    }) => togglableColumns.includes(field)) : sortedColumns;\n    if (!searchValue) {\n      return togglableSortedColumns;\n    }\n    return togglableSortedColumns.filter(column => searchPredicate(column, searchValue.toLowerCase()));\n  }, [sortedColumns, searchValue, searchPredicate, getTogglableColumns]);\n  const firstSwitchRef = React.useRef(null);\n  React.useEffect(() => {\n    if (autoFocusSearchField) {\n      searchInputRef.current.focus();\n    } else if (firstSwitchRef.current && typeof firstSwitchRef.current.focus === 'function') {\n      firstSwitchRef.current.focus();\n    }\n  }, [autoFocusSearchField]);\n  let firstHideableColumnFound = false;\n  const isFirstHideableColumn = column => {\n    if (firstHideableColumnFound === false && column.hideable !== false) {\n      firstHideableColumnFound = true;\n      return true;\n    }\n    return false;\n  };\n  return /*#__PURE__*/_jsxs(GridPanelWrapper, _extends({}, other, {\n    children: [/*#__PURE__*/_jsx(GridPanelHeader, {\n      children: /*#__PURE__*/_jsx(rootProps.slots.baseTextField, _extends({\n        label: apiRef.current.getLocaleText('columnsPanelTextFieldLabel'),\n        placeholder: apiRef.current.getLocaleText('columnsPanelTextFieldPlaceholder'),\n        inputRef: searchInputRef,\n        value: searchValue,\n        onChange: handleSearchValueChange,\n        variant: \"standard\",\n        fullWidth: true\n      }, (_rootProps$slotProps = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps.baseTextField))\n    }), /*#__PURE__*/_jsx(GridPanelContent, {\n      children: /*#__PURE__*/_jsx(GridColumnsPanelRoot, {\n        className: classes.root,\n        ownerState: rootProps,\n        children: currentColumns.map(column => {\n          var _rootProps$slotProps2;\n          return /*#__PURE__*/_jsxs(GridColumnsPanelRowRoot, {\n            className: classes.columnsPanelRow,\n            ownerState: rootProps,\n            children: [/*#__PURE__*/_jsx(FormControlLabel, {\n              control: /*#__PURE__*/_jsx(rootProps.slots.baseSwitch, _extends({\n                disabled: column.hideable === false,\n                checked: columnVisibilityModel[column.field] !== false,\n                onClick: toggleColumn,\n                name: column.field,\n                size: \"small\",\n                inputRef: isFirstHideableColumn(column) ? firstSwitchRef : undefined\n              }, (_rootProps$slotProps2 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps2.baseSwitch)),\n              label: column.headerName || column.field\n            }), !rootProps.disableColumnReorder && GRID_EXPERIMENTAL_ENABLED && /*#__PURE__*/_jsx(GridIconButtonRoot, {\n              draggable: true,\n              \"aria-label\": apiRef.current.getLocaleText('columnsPanelDragIconLabel'),\n              title: apiRef.current.getLocaleText('columnsPanelDragIconLabel'),\n              size: \"small\",\n              disabled: true,\n              children: /*#__PURE__*/_jsx(rootProps.slots.columnReorderIcon, {})\n            })]\n          }, column.field);\n        })\n      })\n    }), disableShowAllButton && disableHideAllButton ? null : /*#__PURE__*/_jsxs(GridPanelFooter, {\n      children: [!disableHideAllButton ? /*#__PURE__*/_jsx(rootProps.slots.baseButton, _extends({\n        onClick: () => toggleAllColumns(false)\n      }, (_rootProps$slotProps3 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps3.baseButton, {\n        disabled: disableHideAllButton,\n        children: apiRef.current.getLocaleText('columnsPanelHideAllButton')\n      })) : /*#__PURE__*/_jsx(\"span\", {}), !disableShowAllButton ? /*#__PURE__*/_jsx(rootProps.slots.baseButton, _extends({\n        onClick: () => toggleAllColumns(true)\n      }, (_rootProps$slotProps4 = rootProps.slotProps) == null ? void 0 : _rootProps$slotProps4.baseButton, {\n        disabled: disableShowAllButton,\n        children: apiRef.current.getLocaleText('columnsPanelShowAllButton')\n      })) : null]\n    })]\n  }));\n}\nprocess.env.NODE_ENV !== \"production\" ? GridColumnsPanel.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * If `true`, the column search field will be focused automatically.\n   * If `false`, the first column switch input will be focused automatically.\n   * This helps to avoid input keyboard panel to popup automatically on touch devices.\n   * @default true\n   */\n  autoFocusSearchField: PropTypes.bool,\n  /**\n   * If `true`, the `Hide all` button will not be displayed.\n   * @default false\n   */\n  disableHideAllButton: PropTypes.bool,\n  /**\n   * If `true`, the `Show all` button will be disabled\n   * @default false\n   */\n  disableShowAllButton: PropTypes.bool,\n  /**\n   * Returns the list of togglable columns.\n   * If used, only those columns will be displayed in the panel\n   * which are passed as the return value of the function.\n   * @param {GridColDef[]} columns The `ColDef` list of all columns.\n   * @returns {GridColDef['field'][]} The list of togglable columns' field names.\n   */\n  getTogglableColumns: PropTypes.func,\n  searchPredicate: PropTypes.func,\n  slotProps: PropTypes.object,\n  sort: PropTypes.oneOf(['asc', 'desc'])\n} : void 0;\nexport { GridColumnsPanel };","map":null,"metadata":{},"sourceType":"module"}