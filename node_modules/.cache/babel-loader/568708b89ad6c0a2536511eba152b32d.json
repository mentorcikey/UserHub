{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"changeReason\", \"unstable_updateValueOnRender\"],\n  _excluded2 = [\"align\", \"children\", \"editCellState\", \"colIndex\", \"column\", \"cellMode\", \"field\", \"formattedValue\", \"hasFocus\", \"height\", \"isEditable\", \"isSelected\", \"rowId\", \"tabIndex\", \"value\", \"width\", \"className\", \"showRightBorder\", \"extendRowFullWidth\", \"row\", \"colSpan\", \"disableDragEvents\", \"isNotVisible\", \"onClick\", \"onDoubleClick\", \"onMouseDown\", \"onMouseUp\", \"onMouseOver\", \"onKeyDown\", \"onKeyUp\", \"onDragEnter\", \"onDragOver\"],\n  _excluded3 = [\"column\", \"rowId\", \"editCellState\", \"align\", \"children\", \"colIndex\", \"height\", \"width\", \"className\", \"showRightBorder\", \"extendRowFullWidth\", \"row\", \"colSpan\", \"disableDragEvents\", \"isNotVisible\", \"onClick\", \"onDoubleClick\", \"onMouseDown\", \"onMouseUp\", \"onMouseOver\", \"onKeyDown\", \"onKeyUp\", \"onDragEnter\", \"onDragOver\"],\n  _excluded4 = [\"changeReason\", \"unstable_updateValueOnRender\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_useForkRef as useForkRef, unstable_composeClasses as composeClasses, unstable_ownerDocument as ownerDocument, unstable_capitalize as capitalize } from '@mui/utils';\nimport { fastMemo } from '../../utils/fastMemo';\nimport { doesSupportPreventScroll } from '../../utils/doesSupportPreventScroll';\nimport { getDataGridUtilityClass, gridClasses } from '../../constants/gridClasses';\nimport { GridCellModes } from '../../models';\nimport { useGridSelector, objectShallowCompare } from '../../hooks/utils/useGridSelector';\nimport { useGridApiContext } from '../../hooks/utils/useGridApiContext';\nimport { useGridRootProps } from '../../hooks/utils/useGridRootProps';\nimport { gridFocusCellSelector } from '../../hooks/features/focus/gridFocusStateSelector';\nimport { MissingRowIdError } from '../../hooks/features/rows/useGridParamsApi';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst EMPTY_CELL_PARAMS = {\n  id: -1,\n  field: '__unset__',\n  row: {},\n  rowNode: {\n    id: -1,\n    depth: 0,\n    type: 'leaf',\n    parent: -1,\n    groupingKey: null\n  },\n  colDef: {\n    type: 'string',\n    field: '__unset__',\n    computedWidth: 0\n  },\n  cellMode: GridCellModes.View,\n  hasFocus: false,\n  tabIndex: -1,\n  value: null,\n  formattedValue: '__unset__',\n  isEditable: false,\n  api: {}\n};\nconst useUtilityClasses = ownerState => {\n  const {\n    align,\n    showRightBorder,\n    isEditable,\n    isSelected,\n    isSelectionMode,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['cell', `cell--text${capitalize(align)}`, isEditable && 'cell--editable', isSelected && 'selected', showRightBorder && 'cell--withRightBorder', isSelectionMode && !isEditable && 'cell--selectionMode', 'withBorderColor'],\n    content: ['cellContent']\n  };\n  return composeClasses(slots, getDataGridUtilityClass, classes);\n};\nlet warnedOnce = false;\n\n// GridCellWrapper is a compatibility layer for the V6 cell slot. If we can use the more efficient\n// `GridCellV7`, we should. That component is a merge of `GridCellWrapper` and `GridCell`.\n// TODO(v7): Remove the wrapper & cellV6 and use the cellV7 exclusively.\n// TODO(v7): Removing the wrapper will break the docs performance visualization demo.\nconst GridCellWrapper = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const {\n    column,\n    rowId,\n    editCellState\n  } = props;\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const field = column.field;\n  const cellParamsWithAPI = useGridSelector(apiRef, () => {\n    // This is required because `.getCellParams` tries to get the `state.rows.tree` entry\n    // associated with `rowId`/`fieldId`, but this selector runs after the state has been\n    // updated, while `rowId`/`fieldId` reference an entry in the old state.\n    try {\n      const cellParams = apiRef.current.getCellParams(rowId, field);\n      const result = cellParams;\n      result.api = apiRef.current;\n      return result;\n    } catch (e) {\n      if (e instanceof MissingRowIdError) {\n        return EMPTY_CELL_PARAMS;\n      }\n      throw e;\n    }\n  }, objectShallowCompare);\n  const isSelected = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors('isCellSelected', false, {\n    id: rowId,\n    field\n  }));\n  if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {\n    return null;\n  }\n  const {\n    cellMode,\n    hasFocus,\n    isEditable,\n    value,\n    formattedValue\n  } = cellParamsWithAPI;\n  const managesOwnFocus = column.type === 'actions';\n  const tabIndex = (cellMode === 'view' || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;\n  const {\n    classes: rootClasses,\n    getCellClassName\n  } = rootProps;\n  const classNames = apiRef.current.unstable_applyPipeProcessors('cellClassName', [], {\n    id: rowId,\n    field\n  });\n  if (column.cellClassName) {\n    classNames.push(typeof column.cellClassName === 'function' ? column.cellClassName(cellParamsWithAPI) : column.cellClassName);\n  }\n  if (getCellClassName) {\n    classNames.push(getCellClassName(cellParamsWithAPI));\n  }\n  let children;\n  if (editCellState == null && column.renderCell) {\n    children = column.renderCell(cellParamsWithAPI);\n    classNames.push(gridClasses['cell--withRenderer']);\n    classNames.push(rootClasses == null ? void 0 : rootClasses['cell--withRenderer']);\n  }\n  if (editCellState != null && column.renderEditCell) {\n    const updatedRow = apiRef.current.getRowWithUpdatedValues(rowId, column.field);\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const editCellStateRest = _objectWithoutPropertiesLoose(editCellState, _excluded);\n    const params = _extends({}, cellParamsWithAPI, {\n      row: updatedRow\n    }, editCellStateRest);\n    children = column.renderEditCell(params);\n    classNames.push(gridClasses['cell--editing']);\n    classNames.push(rootClasses == null ? void 0 : rootClasses['cell--editing']);\n  }\n  const {\n    slots\n  } = rootProps;\n  const CellComponent = slots.cell;\n  const cellProps = _extends({}, props, {\n    ref,\n    field,\n    formattedValue,\n    hasFocus,\n    isEditable,\n    isSelected,\n    value,\n    cellMode,\n    children,\n    tabIndex,\n    className: clsx(classNames)\n  });\n  return /*#__PURE__*/React.createElement(CellComponent, cellProps);\n});\nconst GridCell = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _rootProps$experiment, _rootProps$experiment2;\n  const {\n      align,\n      children: childrenProp,\n      colIndex,\n      column,\n      cellMode,\n      field,\n      formattedValue,\n      hasFocus,\n      height,\n      isEditable,\n      isSelected,\n      rowId,\n      tabIndex,\n      value,\n      width,\n      className,\n      showRightBorder,\n      colSpan,\n      disableDragEvents,\n      isNotVisible,\n      onClick,\n      onDoubleClick,\n      onMouseDown,\n      onMouseUp,\n      onMouseOver,\n      onKeyDown,\n      onKeyUp,\n      onDragEnter,\n      onDragOver\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded2);\n  const valueToRender = formattedValue == null ? value : formattedValue;\n  const cellRef = React.useRef(null);\n  const handleRef = useForkRef(ref, cellRef);\n  const focusElementRef = React.useRef(null);\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const ownerState = {\n    align,\n    showRightBorder,\n    isEditable,\n    classes: rootProps.classes,\n    isSelected\n  };\n  const classes = useUtilityClasses(ownerState);\n  const publishMouseUp = React.useCallback(eventName => event => {\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n  }, [apiRef, field, onMouseUp, rowId]);\n  const publishMouseDown = React.useCallback(eventName => event => {\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n  }, [apiRef, field, onMouseDown, rowId]);\n  const publish = React.useCallback((eventName, propHandler) => event => {\n    // The row might have been deleted during the click\n    if (!apiRef.current.getRow(rowId)) {\n      return;\n    }\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (propHandler) {\n      propHandler(event);\n    }\n  }, [apiRef, field, rowId]);\n  const style = React.useMemo(() => {\n    if (isNotVisible) {\n      return {\n        padding: 0,\n        opacity: 0,\n        width: 0,\n        border: 0\n      };\n    }\n    const cellStyle = {\n      minWidth: width,\n      maxWidth: width,\n      minHeight: height,\n      maxHeight: height === 'auto' ? 'none' : height // max-height doesn't support \"auto\"\n    };\n\n    return cellStyle;\n  }, [width, height, isNotVisible]);\n  React.useEffect(() => {\n    if (!hasFocus || cellMode === GridCellModes.Edit) {\n      return;\n    }\n    const doc = ownerDocument(apiRef.current.rootElementRef.current);\n    if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {\n      const focusableElement = cellRef.current.querySelector('[tabindex=\"0\"]');\n      const elementToFocus = focusElementRef.current || focusableElement || cellRef.current;\n      if (doesSupportPreventScroll()) {\n        elementToFocus.focus({\n          preventScroll: true\n        });\n      } else {\n        const scrollPosition = apiRef.current.getScrollPosition();\n        elementToFocus.focus();\n        apiRef.current.scroll(scrollPosition);\n      }\n    }\n  }, [hasFocus, cellMode, apiRef]);\n  let handleFocus = other.onFocus;\n  if (process.env.NODE_ENV === 'test' && (_rootProps$experiment = rootProps.experimentalFeatures) != null && _rootProps$experiment.warnIfFocusStateIsNotSynced) {\n    handleFocus = event => {\n      const focusedCell = gridFocusCellSelector(apiRef);\n      if ((focusedCell == null ? void 0 : focusedCell.id) === rowId && focusedCell.field === field) {\n        if (typeof other.onFocus === 'function') {\n          other.onFocus(event);\n        }\n        return;\n      }\n      if (!warnedOnce) {\n        console.warn([`MUI: The cell with id=${rowId} and field=${field} received focus.`, `According to the state, the focus should be at id=${focusedCell == null ? void 0 : focusedCell.id}, field=${focusedCell == null ? void 0 : focusedCell.field}.`, \"Not syncing the state may cause unwanted behaviors since the `cellFocusIn` event won't be fired.\", 'Call `fireEvent.mouseUp` before the `fireEvent.click` to sync the focus with the state.'].join('\\n'));\n        warnedOnce = true;\n      }\n    };\n  }\n  const managesOwnFocus = column.type === 'actions';\n  let children = childrenProp;\n  if (children === undefined) {\n    const valueString = valueToRender == null ? void 0 : valueToRender.toString();\n    children = /*#__PURE__*/_jsx(\"div\", {\n      className: classes.content,\n      title: valueString,\n      role: \"presentation\",\n      children: valueString\n    });\n  }\n  if ( /*#__PURE__*/React.isValidElement(children) && managesOwnFocus) {\n    children = /*#__PURE__*/React.cloneElement(children, {\n      focusElementRef\n    });\n  }\n  const draggableEventHandlers = disableDragEvents ? null : {\n    onDragEnter: publish('cellDragEnter', onDragEnter),\n    onDragOver: publish('cellDragOver', onDragOver)\n  };\n  const ariaV7 = (_rootProps$experiment2 = rootProps.experimentalFeatures) == null ? void 0 : _rootProps$experiment2.ariaV7;\n  return /*#__PURE__*/(\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    _jsx(\"div\", _extends({\n      ref: handleRef,\n      className: clsx(className, classes.root),\n      role: ariaV7 ? 'gridcell' : 'cell',\n      \"data-field\": field,\n      \"data-colindex\": colIndex,\n      \"aria-colindex\": colIndex + 1,\n      \"aria-colspan\": colSpan,\n      style: style,\n      tabIndex: tabIndex,\n      onClick: publish('cellClick', onClick),\n      onDoubleClick: publish('cellDoubleClick', onDoubleClick),\n      onMouseOver: publish('cellMouseOver', onMouseOver),\n      onMouseDown: publishMouseDown('cellMouseDown'),\n      onMouseUp: publishMouseUp('cellMouseUp'),\n      onKeyDown: publish('cellKeyDown', onKeyDown),\n      onKeyUp: publish('cellKeyUp', onKeyUp)\n    }, draggableEventHandlers, other, {\n      onFocus: handleFocus,\n      children: children\n    }))\n  );\n});\nconst MemoizedCellWrapper = fastMemo(GridCellWrapper);\nprocess.env.NODE_ENV !== \"production\" ? GridCellWrapper.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  align: PropTypes.oneOf(['center', 'left', 'right']),\n  className: PropTypes.string,\n  colIndex: PropTypes.number,\n  colSpan: PropTypes.number,\n  column: PropTypes.object,\n  disableDragEvents: PropTypes.bool,\n  height: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  onClick: PropTypes.func,\n  onDoubleClick: PropTypes.func,\n  onDragEnter: PropTypes.func,\n  onDragOver: PropTypes.func,\n  onKeyDown: PropTypes.func,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  rowId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  showRightBorder: PropTypes.bool,\n  width: PropTypes.number\n} : void 0;\nprocess.env.NODE_ENV !== \"production\" ? GridCell.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  align: PropTypes.oneOf(['center', 'left', 'right']),\n  cellMode: PropTypes.oneOf(['edit', 'view']),\n  children: PropTypes.node,\n  className: PropTypes.string,\n  colIndex: PropTypes.number,\n  colSpan: PropTypes.number,\n  column: PropTypes.object,\n  disableDragEvents: PropTypes.bool,\n  editCellState: PropTypes.shape({\n    changeReason: PropTypes.oneOf(['debouncedSetEditCellValue', 'setEditCellValue']),\n    isProcessingProps: PropTypes.bool,\n    isValidating: PropTypes.bool,\n    value: PropTypes.any\n  }),\n  isNotVisible: PropTypes.bool,\n  height: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  onClick: PropTypes.func,\n  onDoubleClick: PropTypes.func,\n  onDragEnter: PropTypes.func,\n  onDragOver: PropTypes.func,\n  onKeyDown: PropTypes.func,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  rowId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  showRightBorder: PropTypes.bool,\n  width: PropTypes.number\n} : void 0;\nexport { MemoizedCellWrapper as GridCellWrapper, GridCell };\nconst GridCellV7 = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _rootProps$unstable_c, _rootProps$experiment3, _rootProps$experiment4;\n  const {\n      column,\n      rowId,\n      editCellState,\n      align,\n      colIndex,\n      height,\n      width,\n      className,\n      showRightBorder,\n      colSpan,\n      disableDragEvents,\n      isNotVisible,\n      onClick,\n      onDoubleClick,\n      onMouseDown,\n      onMouseUp,\n      onMouseOver,\n      onKeyDown,\n      onKeyUp,\n      onDragEnter,\n      onDragOver\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded3);\n  const apiRef = useGridApiContext();\n  const rootProps = useGridRootProps();\n  const field = column.field;\n  const cellParamsWithAPI = useGridSelector(apiRef, () => {\n    // This is required because `.getCellParams` tries to get the `state.rows.tree` entry\n    // associated with `rowId`/`fieldId`, but this selector runs after the state has been\n    // updated, while `rowId`/`fieldId` reference an entry in the old state.\n    try {\n      const cellParams = apiRef.current.getCellParams(rowId, field);\n      const result = cellParams;\n      result.api = apiRef.current;\n      return result;\n    } catch (e) {\n      if (e instanceof MissingRowIdError) {\n        return EMPTY_CELL_PARAMS;\n      }\n      throw e;\n    }\n  }, objectShallowCompare);\n  const isSelected = useGridSelector(apiRef, () => apiRef.current.unstable_applyPipeProcessors('isCellSelected', false, {\n    id: rowId,\n    field\n  }));\n  const {\n    cellMode,\n    hasFocus,\n    isEditable,\n    value,\n    formattedValue\n  } = cellParamsWithAPI;\n  const managesOwnFocus = column.type === 'actions';\n  const tabIndex = (cellMode === 'view' || !isEditable) && !managesOwnFocus ? cellParamsWithAPI.tabIndex : -1;\n  const {\n    classes: rootClasses,\n    getCellClassName\n  } = rootProps;\n  const classNames = apiRef.current.unstable_applyPipeProcessors('cellClassName', [], {\n    id: rowId,\n    field\n  });\n  if (column.cellClassName) {\n    classNames.push(typeof column.cellClassName === 'function' ? column.cellClassName(cellParamsWithAPI) : column.cellClassName);\n  }\n  if (getCellClassName) {\n    classNames.push(getCellClassName(cellParamsWithAPI));\n  }\n  const valueToRender = formattedValue == null ? value : formattedValue;\n  const cellRef = React.useRef(null);\n  const handleRef = useForkRef(ref, cellRef);\n  const focusElementRef = React.useRef(null);\n  // @ts-expect-error To access `unstable_cellSelection` flag as it's a `premium` feature\n  const isSelectionMode = (_rootProps$unstable_c = rootProps.unstable_cellSelection) != null ? _rootProps$unstable_c : false;\n  const ownerState = {\n    align,\n    showRightBorder,\n    isEditable,\n    classes: rootProps.classes,\n    isSelected,\n    isSelectionMode\n  };\n  const classes = useUtilityClasses(ownerState);\n  const publishMouseUp = React.useCallback(eventName => event => {\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (onMouseUp) {\n      onMouseUp(event);\n    }\n  }, [apiRef, field, onMouseUp, rowId]);\n  const publishMouseDown = React.useCallback(eventName => event => {\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (onMouseDown) {\n      onMouseDown(event);\n    }\n  }, [apiRef, field, onMouseDown, rowId]);\n  const publish = React.useCallback((eventName, propHandler) => event => {\n    // The row might have been deleted during the click\n    if (!apiRef.current.getRow(rowId)) {\n      return;\n    }\n    const params = apiRef.current.getCellParams(rowId, field || '');\n    apiRef.current.publishEvent(eventName, params, event);\n    if (propHandler) {\n      propHandler(event);\n    }\n  }, [apiRef, field, rowId]);\n  const style = React.useMemo(() => {\n    if (isNotVisible) {\n      return {\n        padding: 0,\n        opacity: 0,\n        width: 0,\n        border: 0\n      };\n    }\n    const cellStyle = {\n      minWidth: width,\n      maxWidth: width,\n      minHeight: height,\n      maxHeight: height === 'auto' ? 'none' : height // max-height doesn't support \"auto\"\n    };\n\n    return cellStyle;\n  }, [width, height, isNotVisible]);\n  React.useEffect(() => {\n    if (!hasFocus || cellMode === GridCellModes.Edit) {\n      return;\n    }\n    const doc = ownerDocument(apiRef.current.rootElementRef.current);\n    if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {\n      const focusableElement = cellRef.current.querySelector('[tabindex=\"0\"]');\n      const elementToFocus = focusElementRef.current || focusableElement || cellRef.current;\n      if (doesSupportPreventScroll()) {\n        elementToFocus.focus({\n          preventScroll: true\n        });\n      } else {\n        const scrollPosition = apiRef.current.getScrollPosition();\n        elementToFocus.focus();\n        apiRef.current.scroll(scrollPosition);\n      }\n    }\n  }, [hasFocus, cellMode, apiRef]);\n  if (cellParamsWithAPI === EMPTY_CELL_PARAMS) {\n    return null;\n  }\n  let handleFocus = other.onFocus;\n  if (process.env.NODE_ENV === 'test' && (_rootProps$experiment3 = rootProps.experimentalFeatures) != null && _rootProps$experiment3.warnIfFocusStateIsNotSynced) {\n    handleFocus = event => {\n      const focusedCell = gridFocusCellSelector(apiRef);\n      if ((focusedCell == null ? void 0 : focusedCell.id) === rowId && focusedCell.field === field) {\n        if (typeof other.onFocus === 'function') {\n          other.onFocus(event);\n        }\n        return;\n      }\n      if (!warnedOnce) {\n        console.warn([`MUI: The cell with id=${rowId} and field=${field} received focus.`, `According to the state, the focus should be at id=${focusedCell == null ? void 0 : focusedCell.id}, field=${focusedCell == null ? void 0 : focusedCell.field}.`, \"Not syncing the state may cause unwanted behaviors since the `cellFocusIn` event won't be fired.\", 'Call `fireEvent.mouseUp` before the `fireEvent.click` to sync the focus with the state.'].join('\\n'));\n        warnedOnce = true;\n      }\n    };\n  }\n  let children;\n  if (editCellState == null && column.renderCell) {\n    children = column.renderCell(cellParamsWithAPI);\n    classNames.push(gridClasses['cell--withRenderer']);\n    classNames.push(rootClasses == null ? void 0 : rootClasses['cell--withRenderer']);\n  }\n  if (editCellState != null && column.renderEditCell) {\n    const updatedRow = apiRef.current.getRowWithUpdatedValues(rowId, column.field);\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const editCellStateRest = _objectWithoutPropertiesLoose(editCellState, _excluded4);\n    const params = _extends({}, cellParamsWithAPI, {\n      row: updatedRow\n    }, editCellStateRest);\n    children = column.renderEditCell(params);\n    classNames.push(gridClasses['cell--editing']);\n    classNames.push(rootClasses == null ? void 0 : rootClasses['cell--editing']);\n  }\n  if (children === undefined) {\n    const valueString = valueToRender == null ? void 0 : valueToRender.toString();\n    children = /*#__PURE__*/_jsx(\"div\", {\n      className: classes.content,\n      title: valueString,\n      role: \"presentation\",\n      children: valueString\n    });\n  }\n  if ( /*#__PURE__*/React.isValidElement(children) && managesOwnFocus) {\n    children = /*#__PURE__*/React.cloneElement(children, {\n      focusElementRef\n    });\n  }\n  const draggableEventHandlers = disableDragEvents ? null : {\n    onDragEnter: publish('cellDragEnter', onDragEnter),\n    onDragOver: publish('cellDragOver', onDragOver)\n  };\n  const ariaV7 = (_rootProps$experiment4 = rootProps.experimentalFeatures) == null ? void 0 : _rootProps$experiment4.ariaV7;\n  return /*#__PURE__*/(\n    // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n    _jsx(\"div\", _extends({\n      ref: handleRef,\n      className: clsx(className, classNames, classes.root),\n      role: ariaV7 ? 'gridcell' : 'cell',\n      \"data-field\": field,\n      \"data-colindex\": colIndex,\n      \"aria-colindex\": colIndex + 1,\n      \"aria-colspan\": colSpan,\n      style: style,\n      tabIndex: tabIndex,\n      onClick: publish('cellClick', onClick),\n      onDoubleClick: publish('cellDoubleClick', onDoubleClick),\n      onMouseOver: publish('cellMouseOver', onMouseOver),\n      onMouseDown: publishMouseDown('cellMouseDown'),\n      onMouseUp: publishMouseUp('cellMouseUp'),\n      onKeyDown: publish('cellKeyDown', onKeyDown),\n      onKeyUp: publish('cellKeyUp', onKeyUp)\n    }, draggableEventHandlers, other, {\n      onFocus: handleFocus,\n      children: children\n    }))\n  );\n});\nprocess.env.NODE_ENV !== \"production\" ? GridCellV7.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  align: PropTypes.oneOf(['center', 'left', 'right']).isRequired,\n  className: PropTypes.string,\n  colIndex: PropTypes.number.isRequired,\n  colSpan: PropTypes.number,\n  column: PropTypes.object.isRequired,\n  disableDragEvents: PropTypes.bool,\n  editCellState: PropTypes.shape({\n    changeReason: PropTypes.oneOf(['debouncedSetEditCellValue', 'setEditCellValue']),\n    isProcessingProps: PropTypes.bool,\n    isValidating: PropTypes.bool,\n    value: PropTypes.any\n  }),\n  height: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]).isRequired,\n  isNotVisible: PropTypes.bool,\n  onClick: PropTypes.func,\n  onDoubleClick: PropTypes.func,\n  onDragEnter: PropTypes.func,\n  onDragOver: PropTypes.func,\n  onKeyDown: PropTypes.func,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  rowId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  showRightBorder: PropTypes.bool,\n  width: PropTypes.number.isRequired\n} : void 0;\nconst MemoizedGridCellV7 = fastMemo(GridCellV7);\nexport { MemoizedGridCellV7 as GridCellV7 };","map":null,"metadata":{},"sourceType":"module"}